#!/bin/bash

# Instalador Automatizado Completo de Servidor
# Instala: Ubuntu/Debian updates, Docker Swarm, Portainer (com senha), N8N, Evolution API
# Uso: ./install_complete_server.sh DOMAIN PORTAINER_SUBDOMAIN N8N_EDITOR_SUBDOMAIN N8N_WEBHOOK_SUBDOMAIN EVOLUTION_SUBDOMAIN WEBHOOK_URL [PORTAINER_PASSWORD]
# Exemplo: ./install_complete_server.sh exemplo.com painel editor webhook api https://webhook.site/uuid minhasenha123

set -e  # Para no primeiro erro

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Inicializar captura de logs
INSTALL_LOG=""
ERROR_LOG=""
INSTALL_STATUS="success"

# Função para logging
log() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_entry="[$timestamp] $message"
    echo -e "${GREEN}$log_entry${NC}"
    INSTALL_LOG+="$log_entry\n"
}

error() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local error_entry="[$timestamp] ERROR: $message"
    echo -e "${RED}$error_entry${NC}"
    ERROR_LOG+="$error_entry\n"
    INSTALL_STATUS="error"
}

warning() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local warning_entry="[$timestamp] WARNING: $message"
    echo -e "${YELLOW}$warning_entry${NC}"
    INSTALL_LOG+="$warning_entry\n"
}

# Função para enviar webhook final
send_final_webhook() {
    local final_status="$1"
    local final_message="$2"
    
    # Escapar caracteres especiais para JSON
    local escaped_install_log=$(echo -e "$INSTALL_LOG" | sed 's/\\/\\\\/g; s/"/\\"/g; s/$/\\n/g' | tr -d '\n')
    local escaped_error_log=$(echo -e "$ERROR_LOG" | sed 's/\\/\\\\/g; s/"/\\"/g; s/$/\\n/g' | tr -d '\n')
    
    # Preparar os dados para o webhook
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local hostname=$(hostname)
    local server_ip=$(hostname -I | awk '{print $1}')
    
    # Criar objeto JSON para o webhook com todos os dados
    local WEBHOOK_DATA=$(cat << EOF
{
  "installation_id": "${INSTALLATION_ID}",
  "timestamp": "${timestamp}",
  "hostname": "${hostname}",
  "server_ip": "${server_ip}",
  "status": "${final_status}",
  "message": "${final_message}",
  "install_log": "${escaped_install_log}",
  "error_log": "${escaped_error_log}",
  "domain": "${DOMAIN}",
  "portainer": {
    "url": "https://${PORTAINER_DOMAIN}",
    "username": "admin",
    "password": "${PORTAINER_PASSWORD}"
  },
  "n8n": {
    "editor_url": "https://${N8N_EDITOR_DOMAIN}",
    "webhook_url": "https://${N8N_WEBHOOK_DOMAIN}",
    "encryption_key": "${N8N_ENCRYPTION_KEY}",
    "suggested_password": "${N8N_SUGGESTED_PASSWORD}"
  },
  "evolution": {
    "url": "https://${EVOLUTION_DOMAIN}",
    "api_key": "${EVOLUTION_API_KEY}",
    "manager_url": "https://${EVOLUTION_DOMAIN}/manager"
  }
}
EOF
)

    # Enviar dados para o webhook
    log "Enviando dados da instalação para o webhook..."
    local WEBHOOK_RESPONSE=$(curl -s -X POST "${WEBHOOK_URL}" \
      -H "Content-Type: application/json" \
      -d "${WEBHOOK_DATA}" \
      -w "\n%{http_code}")

    local HTTP_CODE=$(echo "$WEBHOOK_RESPONSE" | tail -n1)
    local WEBHOOK_BODY=$(echo "$WEBHOOK_RESPONSE" | sed '$d')

    if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ] || [ "$HTTP_CODE" -eq 202 ]; then
        log "Dados enviados com sucesso para o webhook."
    else
        error "Não foi possível enviar os dados para o webhook. Código HTTP: ${HTTP_CODE}. Resposta: ${WEBHOOK_BODY}"
    fi
}

# Função para tratamento de erro e saída
error_exit() {
    error "$1"
    send_final_webhook "error" "$1"
    exit 1
}

# Verificar parâmetros
if [ $# -lt 6 ]; then
    error_exit "Uso: $0 DOMAIN PORTAINER_SUBDOMAIN N8N_EDITOR_SUBDOMAIN N8N_WEBHOOK_SUBDOMAIN EVOLUTION_SUBDOMAIN WEBHOOK_URL [PORTAINER_PASSWORD]"
fi

DOMAIN=$1
PORTAINER_SUBDOMAIN=$2
N8N_EDITOR_SUBDOMAIN=$3
N8N_WEBHOOK_SUBDOMAIN=$4
EVOLUTION_SUBDOMAIN=$5
WEBHOOK_URL=$6
# CORREÇÃO: Mudar a geração de senha para 'hex' para evitar caracteres especiais como '/' ou '+'
PORTAINER_PASSWORD=${7:-$(openssl rand -hex 16)}

# Gerar ID único para esta instalação
INSTALLATION_ID=$(openssl rand -hex 8)

# Construir domínios completos
PORTAINER_DOMAIN="${PORTAINER_SUBDOMAIN}.${DOMAIN}"
N8N_EDITOR_DOMAIN="${N8N_EDITOR_SUBDOMAIN}.${DOMAIN}"
N8N_WEBHOOK_DOMAIN="${N8N_WEBHOOK_SUBDOMAIN}.${DOMAIN}"
EVOLUTION_DOMAIN="${EVOLUTION_SUBDOMAIN}.${DOMAIN}"
TRAEFIK_DOMAIN="traefik.${DOMAIN}"

log "=== INICIANDO INSTALAÇÃO COMPLETA DO SERVIDOR ==="
log "Domínio principal: ${DOMAIN}"
log "Portainer: https://${PORTAINER_DOMAIN}"
log "N8N Editor: https://${N8N_EDITOR_DOMAIN}"
log "N8N Webhook: https://${N8N_WEBHOOK_DOMAIN}"
log "Evolution: https://${EVOLUTION_DOMAIN}"
log "Traefik Dashboard: https://${TRAEFIK_DOMAIN}"
log "Installation ID: ${INSTALLATION_ID}"

# LIMPEZA INICIAL - Garantir que não há processos travados
log "Verificando processos em execução..."
# Matar processos apt que possam estar travados
killall apt apt-get dpkg unattended-upgrades 2>/dev/null || true
# Aguardar um momento
sleep 5

# ==============================================================================
# CORREÇÃO: Remover stacks antigas para garantir que o Portainer as redescubra
# ==============================================================================
log "=== ETAPA 0: REMOVENDO STACKS ANTERIORES ==="
log "Limpando instalações anteriores para garantir um ambiente limpo..."
docker stack rm portainer traefik n8n n8n_redis n8n_postgres evolution evolution_redis evolution_postgres 2>/dev/null || true
log "Aguardando a remoção completa das stacks..."
sleep 15


# 1. ATUALIZAR SISTEMA
log "=== ETAPA 1: ATUALIZANDO SISTEMA ==="
export DEBIAN_FRONTEND=noninteractive

log "Atualizando lista de pacotes..."
apt-get update -qq

log "Fazendo upgrade do sistema..."
apt-get upgrade -y -qq

log "Instalando dependências essenciais..."
apt-get install -y -qq \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    software-properties-common \
    jq \
    openssl \
    wget \
    apache2-utils

# 2. INSTALAR DOCKER
log "=== ETAPA 2: INSTALANDO DOCKER ==="

# Remover versões antigas do Docker se existirem
apt-get remove -y -qq docker docker-engine docker.io containerd runc 2>/dev/null || true

# Adicionar chave GPG oficial do Docker
log "Adicionando chave GPG do Docker..."
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg

# Adicionar repositório do Docker
log "Adicionando repositório do Docker..."
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  tee /etc/apt/sources.list.d/docker.list > /dev/null

# Atualizar e instalar Docker
apt-get update -qq
apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Iniciar e habilitar Docker
systemctl start docker
systemctl enable docker

# Verificar instalação
if ! docker --version > /dev/null 2>&1; then
    error_exit "Falha na instalação do Docker"
fi

log "Docker instalado com sucesso: $(docker --version)"

# 3. CONFIGURAR DOCKER SWARM
log "=== ETAPA 3: CONFIGURANDO DOCKER SWARM ==="

# Sempre forçar reinicialização do swarm para garantir estado limpo
log "Limpando configuração anterior e inicializando Docker Swarm..."
docker swarm leave --force 2>/dev/null || true
sleep 2

# CORREÇÃO: Método mais robusto para pegar o IP principal
SERVER_IP=$(ip route get 1.1.1.1 | awk '{print $7}')
if docker swarm init --advertise-addr $SERVER_IP; then
    log "Docker Swarm inicializado com sucesso como manager"
else
    error_exit "Falha ao inicializar Docker Swarm"
fi

# Verificar se o swarm está funcionando corretamente
if ! docker node ls >/dev/null 2>&1; then
    error_exit "Docker Swarm não está funcionando corretamente"
fi

log "Docker Swarm configurado e operacional"

# 4. CRIAR REDES
log "=== ETAPA 4: CRIANDO REDES ==="

# Criar rede proxy se não existir
if ! docker network ls | grep -q "proxy"; then
    docker network create --driver overlay --attachable proxy
    log "Rede proxy criada"
else
    log "Rede proxy já existe"
fi

# Criar rede GrowthNet se não existir
if ! docker network ls | grep -q "GrowthNet"; then
    docker network create --driver overlay --attachable GrowthNet
    log "Rede GrowthNet criada"
else
    log "Rede GrowthNet já existe"
fi

# 5. INSTALAR TRAEFIK
log "=== ETAPA 5: INSTALANDO TRAEFIK ==="

# Criar volume para Traefik se não existir
if ! docker volume ls | grep -q "traefik_data"; then
    docker volume create traefik_data
    log "Volume traefik_data criado"
fi

# CORREÇÃO: Adicionando acesso ao dashboard do Traefik com senha
log "Gerando credenciais para o dashboard do Traefik..."
TRAEFIK_USER="admin"
# CORREÇÃO: Mudar a geração de senha para 'hex' para evitar caracteres especiais
TRAEFIK_PASSWORD=$(openssl rand -hex 16)
TRAEFIK_HASHED_PASSWORD=$(htpasswd -nbB ${TRAEFIK_USER} ${TRAEFIK_PASSWORD})

# Criar arquivo de configuração do Traefik
mkdir -p /opt/traefik
cat > /opt/traefik/docker-compose.yml << EOF
version: '3.7'
services:
  traefik:
    image: traefik:v2.10
    command:
      - --api.dashboard=true
      - --providers.docker=true
      - --providers.docker.swarmMode=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=proxy
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --certificatesresolvers.letsencryptresolver.acme.httpchallenge=true
      - --certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web
      - --certificatesresolvers.letsencryptresolver.acme.email=admin@${DOMAIN}
      - --certificatesresolvers.letsencryptresolver.acme.storage=/letsencrypt/acme.json
      - --global.sendanonymoususage=false
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_data:/letsencrypt
    networks:
      - proxy
    deploy:
      mode: global
      placement:
        constraints:
          - node.role == manager
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: any
      labels:
        # CORREÇÃO: Labels para expor o dashboard do Traefik de forma segura
        - traefik.enable=true
        - traefik.http.routers.traefik-dashboard.rule=Host(\`${TRAEFIK_DOMAIN}\`)
        - traefik.http.routers.traefik-dashboard.entrypoints=websecure
        - traefik.http.routers.traefik-dashboard.tls.certresolver=letsencryptresolver
        - traefik.http.routers.traefik-dashboard.service=api@internal
        - traefik.http.routers.traefik-dashboard.middlewares=traefik-auth
        - traefik.http.middlewares.traefik-auth.basicauth.users=${TRAEFIK_HASHED_PASSWORD}

        # Middleware para redirecionamento HTTP -> HTTPS
        - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https
        - traefik.http.routers.redirect-https.rule=hostregexp(\`{host:.+}\`)
        - traefik.http.routers.redirect-https.entrypoints=web
        - traefik.http.routers.redirect-https.middlewares=redirect-to-https

volumes:
  traefik_data:
    external: true

networks:
  proxy:
    external: true
    name: proxy
EOF

# Deploy do Traefik
log "Fazendo deploy do Traefik..."
cd /opt/traefik
docker stack deploy -c docker-compose.yml traefik

# Aguardar Traefik inicializar
log "Aguardando Traefik inicializar..."
sleep 15

# 6. INSTALAR PORTAINER (COM SENHA AUTOMÁTICA)
log "=== ETAPA 6: INSTALANDO PORTAINER ==="

# Criar volume para dados do Portainer
if ! docker volume ls | grep -q "portainer_data"; then
    docker volume create portainer_data
    log "Volume portainer_data criado"
fi

# Criar arquivo docker-compose do Portainer
mkdir -p /opt/portainer
cat > /opt/portainer/docker-compose.yml << EOF
version: '3.7'
services:
  portainer:
    image: portainer/portainer-ce:latest
    command: 
      - --host=unix:///var/run/docker.sock
      - --logo="https://www.growthtap.com.br/logo.png"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
      - /opt:/opt
    networks:
      - proxy
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]
      labels:
        - traefik.enable=true
        - traefik.docker.network=proxy
        - traefik.http.routers.portainer.rule=Host(\`${PORTAINER_DOMAIN}\`)
        - traefik.http.routers.portainer.entrypoints=websecure
        - traefik.http.routers.portainer.tls.certresolver=letsencryptresolver
        - traefik.http.services.portainer.loadbalancer.server.port=9000

volumes:
  portainer_data:
    external: true

networks:
  proxy:
    external: true
    name: proxy
EOF

# Deploy do Portainer
log "Fazendo deploy do Portainer..."
cd /opt/portainer
docker stack deploy -c docker-compose.yml portainer

# Aguardar Portainer inicializar
log "Aguardando Portainer inicializar..."
sleep 30

# Configurar senha via API
log "Configurando senha administrativa do Portainer..."
for i in {1..5}; do
    # CORREÇÃO: Adicionado -k para ignorar verificação de SSL temporariamente
    SETUP_RESPONSE=$(curl -s -k -X POST "https://${PORTAINER_DOMAIN}/api/users/admin/init" \
        -H "Content-Type: application/json" \
        -d "{\"Username\":\"admin\",\"Password\":\"${PORTAINER_PASSWORD}\"}" \
        -w "%{http_code}" -o /tmp/portainer_setup.log)
    
    HTTP_CODE=$(echo "$SETUP_RESPONSE" | tail -c 4)
    
    if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "409" ]; then
        log "Senha do Portainer configurada com sucesso"
        break
    else
        log "Tentativa $i/5 de configuração da senha... (HTTP: $HTTP_CODE)"
        sleep 10
    fi
    
    if [ $i -eq 5 ]; then
        warning "Não foi possível configurar senha via API. A senha pode já ter sido definida ou o serviço está inacessível."
    fi
done

rm -f /tmp/portainer_setup.log

# 7. GERAR CREDENCIAIS PARA N8N E EVOLUTION
log "=== ETAPA 7: GERANDO CREDENCIAIS ==="

# Gerar chave de criptografia do N8N
N8N_ENCRYPTION_KEY=$(openssl rand -hex 16)
log "Chave de criptografia N8N gerada"

# Gerar senha sugerida para N8N
generate_valid_password() {
    while true; do
        password=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 12 | head -n 1)
        if echo "$password" | grep -q '[0-9]' && echo "$password" | grep -q '[A-Z]'; then
            echo "$password"
            break
        fi
    done
}

N8N_SUGGESTED_PASSWORD=$(generate_valid_password)
log "Senha sugerida N8N gerada"

# Gerar API key da Evolution
EVOLUTION_API_KEY=$(openssl rand -hex 16)
log "API key Evolution gerada"

# Gerar senhas PostgreSQL
N8N_POSTGRES_PASSWORD=$(openssl rand -hex 16)
EVOLUTION_POSTGRES_PASSWORD=$(openssl rand -hex 16)
log "Senhas PostgreSQL geradas"

# 8. INSTALAR N8N
log "=== ETAPA 8: INSTALANDO N8N ==="

# Criar volumes N8N
docker volume create n8n_data 2>/dev/null || log "Volume n8n_data já existe"
docker volume create n8n_postgres_data 2>/dev/null || log "Volume n8n_postgres_data já existe"
docker volume create n8n_redis_data 2>/dev/null || log "Volume n8n_redis_data já existe"

mkdir -p /opt/n8n

# Criar stack Redis para N8N
cat > /opt/n8n/n8n_redis.yaml << EOF
version: '3.7'
services:
  redis:
    image: redis:latest
    command: redis-server --appendonly yes
    volumes:
      - n8n_redis_data:/data
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  n8n_redis_data:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOF

# Criar stack PostgreSQL para N8N
cat > /opt/n8n/n8n_postgres.yaml << EOF
version: '3.7'
services:
  postgres:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=${N8N_POSTGRES_PASSWORD}
      - POSTGRES_USER=postgres
      - POSTGRES_DB=n8n_queue
    volumes:
      - n8n_postgres_data:/var/lib/postgresql/data
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  n8n_postgres_data:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOF

# Criar stack principal N8N
cat > /opt/n8n/n8n.yaml << EOF
version: "3.7"
services:
  n8n_editor:
    image: n8nio/n8n:latest
    command: start
    networks:
      - GrowthNet
      - proxy
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=n8n_postgres_postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${N8N_POSTGRES_PASSWORD}
      - N8N_PAYLOAD_SIZE_MAX=67108864
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_EDITOR_DOMAIN}
      - N8N_EDITOR_BASE_URL=https://${N8N_EDITOR_DOMAIN}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_DOMAIN}/
      - N8N_PROTOCOL=https
      - N8N_PORT=5678
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=n8n_redis_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    volumes:
      - n8n_data:/home/node/.n8n
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.docker.network=proxy
        - traefik.http.routers.n8n.rule=Host(\`${N8N_EDITOR_DOMAIN}\`)
        - traefik.http.routers.n8n.entrypoints=websecure
        - traefik.http.routers.n8n.tls.certresolver=letsencryptresolver
        - traefik.http.services.n8n.loadbalancer.server.port=5678

  n8n_webhook:
    image: n8nio/n8n:latest
    command: webhook
    networks:
      - GrowthNet
      - proxy
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=n8n_postgres_postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${N8N_POSTGRES_PASSWORD}
      - N8N_PAYLOAD_SIZE_MAX=67108864
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_EDITOR_DOMAIN}
      - N8N_EDITOR_BASE_URL=https://${N8N_EDITOR_DOMAIN}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_DOMAIN}/
      - N8N_PROTOCOL=https
      - N8N_PORT=5678
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=n8n_redis_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    volumes:
      - n8n_data:/home/node/.n8n
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.docker.network=proxy
        - traefik.http.routers.n8n_webhook.rule=Host(\`${N8N_WEBHOOK_DOMAIN}\`)
        - traefik.http.routers.n8n_webhook.entrypoints=websecure
        - traefik.http.routers.n8n_webhook.tls.certresolver=letsencryptresolver
        - traefik.http.services.n8n_webhook.loadbalancer.server.port=5678

  n8n_worker:
    image: n8nio/n8n:latest
    command: worker --concurrency=10
    networks:
      - GrowthNet
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=n8n_postgres_postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${N8N_POSTGRES_PASSWORD}
      - N8N_PAYLOAD_SIZE_MAX=67108864
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=n8n_redis_redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    volumes:
      - n8n_data:/home/node/.n8n
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager

volumes:
  n8n_data:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
  proxy:
    external: true
    name: proxy
EOF

# Deploy das stacks N8N
log "Fazendo deploy das stacks N8N..."
cd /opt/n8n
docker stack deploy -c n8n_redis.yaml n8n_redis
docker stack deploy -c n8n_postgres.yaml n8n_postgres

# Aguardar Redis e PostgreSQL
log "Aguardando Redis e PostgreSQL inicializarem..."
sleep 15

docker stack deploy -c n8n.yaml n8n

# 9. INSTALAR EVOLUTION API
log "=== ETAPA 9: INSTALANDO EVOLUTION API ==="

# Criar volumes Evolution
docker volume create evolution_redis_data 2>/dev/null || log "Volume evolution_redis_data já existe"
docker volume create evolution_postgres_data 2>/dev/null || log "Volume evolution_postgres_data já existe"  
docker volume create evolution_instances 2>/dev/null || log "Volume evolution_instances já existe"

mkdir -p /opt/evolution

# Criar stack Redis para Evolution
cat > /opt/evolution/evolution_redis.yaml << EOF
version: '3.7'
services:
  redis:
    image: redis:latest
    command: redis-server --appendonly yes
    volumes:
      - evolution_redis_data:/data
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  evolution_redis_data:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOF

# Criar stack PostgreSQL para Evolution
cat > /opt/evolution/evolution_postgres.yaml << EOF
version: '3.7'
services:
  postgres:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=${EVOLUTION_POSTGRES_PASSWORD}
      - POSTGRES_USER=postgres
    volumes:
      - evolution_postgres_data:/var/lib/postgresql/data
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  evolution_postgres_data:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOF

# Criar stack principal Evolution
cat > /opt/evolution/evolution.yaml << EOF
version: '3.7'
services:
  evolution:
    image: atendai/evolution-api:latest
    volumes:
      - evolution_instances:/evolution/instances
    networks:
      - GrowthNet
      - proxy
    environment:
      - SERVER_URL=https://${EVOLUTION_DOMAIN}
      - AUTHENTICATION_API_KEY=${EVOLUTION_API_KEY}
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
      - DEL_INSTANCE=false
      - QRCODE_LIMIT=1902
      - LANGUAGE=pt-BR
      - DATABASE_ENABLED=true
      - DATABASE_PROVIDER=postgresql
      - DATABASE_CONNECTION_URI=postgresql://postgres:${EVOLUTION_POSTGRES_PASSWORD}@evolution_postgres_postgres:5432/evolution
      - DATABASE_CONNECTION_CLIENT_NAME=evolution
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true
      - DATABASE_SAVE_DATA_LABELS=true
      - DATABASE_SAVE_DATA_HISTORIC=true
      - CACHE_REDIS_ENABLED=true
      - CACHE_REDIS_URI=redis://evolution_redis_redis:6379/8
      - CACHE_REDIS_PREFIX_KEY=evolution
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.docker.network=proxy
        - traefik.http.routers.evolution.rule=Host(\`${EVOLUTION_DOMAIN}\`)
        - traefik.http.routers.evolution.entrypoints=websecure
        - traefik.http.routers.evolution.tls.certresolver=letsencryptresolver
        - traefik.http.services.evolution.loadbalancer.server.port=8080

volumes:
  evolution_instances:
    external: true

networks:
  GrowthNet:
    external: true
    name: GrowthNet
  proxy:
    external: true
    name: proxy
EOF

# Deploy das stacks Evolution
log "Fazendo deploy das stacks Evolution..."
cd /opt/evolution
docker stack deploy -c evolution_redis.yaml evolution_redis
docker stack deploy -c evolution_postgres.yaml evolution_postgres

# Aguardar Redis e PostgreSQL
log "Aguardando Redis e PostgreSQL da Evolution inicializarem..."
sleep 15

docker stack deploy -c evolution.yaml evolution

# 10. AGUARDAR TODOS OS SERVIÇOS
log "=== ETAPA 10: AGUARDANDO INICIALIZAÇÃO COMPLETA ==="
log "Aguardando todos os serviços inicializarem completamente..."
sleep 30

# 11. SALVAR CREDENCIAIS
log "=== ETAPA 11: SALVANDO CREDENCIAIS ==="

CREDENTIALS_DIR="/root/.credentials"
mkdir -p "$CREDENTIALS_DIR"
chmod 700 "$CREDENTIALS_DIR"

# Arquivo de credenciais completas
cat > "${CREDENTIALS_DIR}/server_complete.txt" << EOF
=== INSTALAÇÃO COMPLETA DO SERVIDOR ===
Data: $(date)
Domain: ${DOMAIN}
Installation ID: ${INSTALLATION_ID}

=== TRAEFIK DASHBOARD ===
URL: https://${TRAEFIK_DOMAIN}
Username: ${TRAEFIK_USER}
Password: ${TRAEFIK_PASSWORD}

=== PORTAINER ===
URL: https://${PORTAINER_DOMAIN}
Username: admin
Password: ${PORTAINER_PASSWORD}

=== N8N ===
Editor URL: https://${N8N_EDITOR_DOMAIN}
Webhook URL: https://${N8N_WEBHOOK_DOMAIN}
Senha sugerida: ${N8N_SUGGESTED_PASSWORD}
Encryption Key: ${N8N_ENCRYPTION_KEY}
PostgreSQL Password: ${N8N_POSTGRES_PASSWORD}

=== EVOLUTION API ===
URL: https://${EVOLUTION_DOMAIN}
Manager: https://${EVOLUTION_DOMAIN}/manager
API Key: ${EVOLUTION_API_KEY}
PostgreSQL Password: ${EVOLUTION_POSTGRES_PASSWORD}

=== DOCKER STACKS ===
- traefik (proxy reverso)
- portainer (gerenciamento)
- n8n_redis, n8n_postgres, n8n (automação)
- evolution_redis, evolution_postgres, evolution (WhatsApp API)
EOF

chmod 600 "${CREDENTIALS_DIR}/server_complete.txt"

log "Credenciais salvas em ${CREDENTIALS_DIR}/server_complete.txt"

# 12. VERIFICAR STATUS DOS SERVIÇOS
log "=== ETAPA 12: VERIFICANDO STATUS DOS SERVIÇOS ==="

# Função para verificar se um serviço está rodando
check_service() {
    local service_name="$1"
    local max_attempts=30
    local attempt=1
    
    log "Verificando serviço: $service_name"
    
    while [ $attempt -le $max_attempts ]; do
        if docker service ls --format "table {{.Name}}\t{{.Replicas}}" | grep "$service_name" | grep -q "1/1"; then
            log "✓ $service_name está rodando"
            return 0
        fi
        
        log "Tentativa $attempt/$max_attempts para $service_name..."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    warning "⚠ $service_name não respondeu dentro do tempo esperado"
    return 1
}

# Verificar serviços principais
check_service "traefik_traefik"
check_service "portainer_portainer"
check_service "n8n_redis_redis"
check_service "n8n_postgres_postgres" 
check_service "n8n_n8n_editor"
check_service "evolution_redis_redis"
check_service "evolution_postgres_postgres"
check_service "evolution_evolution"

# 13. TESTAR CONECTIVIDADE
log "=== ETAPA 13: TESTANDO CONECTIVIDADE ==="

# Função para testar URL
test_url() {
    local url="$1"
    local name="$2"
    local max_attempts=10
    local attempt=1
    
    log "Testando conectividade: $name"
    
    while [ $attempt -le $max_attempts ]; do
        # CORREÇÃO: Adicionado -k para ignorar verificação de SSL durante o teste
        if curl -s -k --connect-timeout 5 --max-time 10 "$url" > /dev/null 2>&1; then
            log "✓ $name está acessível"
            return 0
        fi
        
        log "Tentativa $attempt/$max_attempts para $name..."
        sleep 3
        attempt=$((attempt + 1))
    done
    
    warning "⚠ $name não está acessível ainda"
    return 1
}

# Aguardar um pouco mais para SSL se configurar
log "Aguardando certificados SSL serem gerados..."
sleep 30

# Testar URLs principais
test_url "https://${PORTAINER_DOMAIN}" "Portainer"
test_url "https://${N8N_EDITOR_DOMAIN}" "N8N Editor"
test_url "https://${EVOLUTION_DOMAIN}" "Evolution API"

# 14. LIMPEZA
log "=== ETAPA 14: LIMPEZA FINAL ==="

# Limpar arquivos temporários
rm -rf /opt/*/docker-compose.yml.bak 2>/dev/null || true

# Limpar cache do apt
apt-get autoremove -y -qq
apt-get autoclean -qq

# 15. RELATÓRIO FINAL
log "=== INSTALAÇÃO CONCLUÍDA COM SUCESSO ==="

echo ""
echo "=================================================="
echo "        INSTALAÇÃO COMPLETA FINALIZADA"
echo "=================================================="
echo ""
echo "🌐 DOMÍNIO PRINCIPAL: ${DOMAIN}"
echo ""
echo "📈 TRAEFIK (Proxy Reverso)"
echo "   URL: https://${TRAEFIK_DOMAIN}"
echo "   Usuário: ${TRAEFIK_USER}"
echo "   Senha: ${TRAEFIK_PASSWORD}"
echo ""
echo "🔧 PORTAINER (Gerenciamento Docker)"
echo "   URL: https://${PORTAINER_DOMAIN}"
echo "   Usuário: admin"
echo "   Senha: ${PORTAINER_PASSWORD}"
echo ""
echo "⚡ N8N (Automação/Workflows)"
echo "   Editor: https://${N8N_EDITOR_DOMAIN}"
echo "   Webhooks: https://${N8N_WEBHOOK_DOMAIN}"
echo "   Senha sugerida: ${N8N_SUGGESTED_PASSWORD}"
echo ""
echo "📱 EVOLUTION API (WhatsApp)"
echo "   API: https://${EVOLUTION_DOMAIN}"
echo "   Manager: https://${EVOLUTION_DOMAIN}/manager"
echo "   API Key: ${EVOLUTION_API_KEY}"
echo ""
echo "📋 CREDENCIAIS SALVAS EM:"
echo "   ${CREDENTIALS_DIR}/server_complete.txt"
echo ""
echo "🚀 PRÓXIMOS PASSOS:"
echo "   1. Acesse o Portainer e o Traefik para gerenciar o ambiente."
echo "   2. Configure seu primeiro workflow no N8N."
echo "   3. Conecte suas instâncias WhatsApp na Evolution API."
echo ""
echo "=================================================="

# Enviar webhook final de sucesso
send_final_webhook "success" "Instalação completa do servidor finalizada com sucesso"

log "Webhook de conclusão enviado. Instalação finalizada!"
log "Installation ID: ${INSTALLATION_ID}"

exit 0

