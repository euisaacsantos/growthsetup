#!/bin/bash
# Script para criar stacks separadas no Portainer para Evo AI (API, Redis e PostgreSQL)
# Uso: ./install-evo-ai.sh <portainer_url> <evo_ai_domain> <portainer_password> [sufixo] [id-xxxx]
# Exemplo: ./install-evo-ai.sh painel.trafegocomia.com evoai.trafegocomia.com senha123 cliente1 id-9876543210
# Ou sem sufixo: ./install-evo-ai.sh painel.trafegocomia.com evoai.trafegocomia.com senha123 "" id-9876543210

# Verificar parâmetros obrigatórios
if [ $# -lt 3 ]; then
    echo "Uso: $0 <portainer_url> <evo_ai_domain> <portainer_password> [sufixo] [id-xxxx]"
    echo "Exemplo: $0 painel.trafegocomia.com evoai.trafegocomia.com senha123 cliente1 id-9876543210"
    echo "Sem sufixo: $0 painel.trafegocomia.com evoai.trafegocomia.com senha123 \"\" id-9876543210"
    exit 1
fi

# Capturar parâmetros da linha de comando
PORTAINER_URL="https://$1"         # URL do Portainer
EVO_AI_DOMAIN="$2"                  # Domínio para a Evo AI
PORTAINER_PASSWORD="$3"             # Senha do Portainer

# Inicializar variáveis
SUFFIX=""
INSTALLATION_ID="sem_id"

# Processar parâmetros opcionais (sufixo e ID)
for param in "${@:4}"; do
    # Verificar se o parâmetro começa com 'id-'
    if [[ "$param" == id-* ]]; then
        INSTALLATION_ID="${param#id-}"  # Remover o prefixo 'id-'
        echo "ID da instalação: $INSTALLATION_ID"
    # Se não for vazio e não começar com 'id-', é o sufixo
    elif [ -n "$param" ]; then
        SUFFIX="_$param"
        echo "Instalando com sufixo: $SUFFIX"
    fi
done

# Configurações adicionais
PORTAINER_USER="admin"              # Usuário do Portainer
EVO_AI_STACK_NAME="evoai${SUFFIX}"   # Nome da stack Evo AI
REDIS_STACK_NAME="evoai_redis${SUFFIX}" # Nome da stack Redis com prefixo evoai_
PG_STACK_NAME="evoai_postgres${SUFFIX}"  # Nome da stack PostgreSQL com prefixo evoai_

WEBHOOK_URL="https://setup.growthtap.com.br/webhook/bf813e80-f036-400b-acae-904d703df6dd"

# Cores para formatação
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
RESET="\e[0m"
BEGE="\e[97m"

# Função para exibir erros e sair
error_exit() {
    echo -e "${VERMELHO}ERRO: $1${RESET}" >&2
    exit 1
}

# Criar volumes Docker necessários
echo -e "${VERDE}Criando volumes Docker...${RESET}"
docker volume create "evo-ai-redis-data${SUFFIX}" 2>/dev/null || echo "Volume evo-ai-redis-data${SUFFIX} já existe."
docker volume create "evo-ai-postgres-data${SUFFIX}" 2>/dev/null || echo "Volume evo-ai-postgres-data${SUFFIX} já existe."

# Criar rede overlay se não existir
docker network create --driver overlay GrowthNet 2>/dev/null || echo "Rede GrowthNet já existe."

# Criar arquivo docker-compose para a stack Redis
echo -e "${VERDE}Criando arquivo docker-compose para a stack Redis...${RESET}"
cat > "${REDIS_STACK_NAME}.yaml" <<EOL
version: '3.8'
services:
  redis${SUFFIX}:
    image: redis:alpine
    command:
      - redis-server
      - --appendonly
      - "yes"
      - --requirepass
      - ""
    ports:
      - "6379:6379"
    volumes:
      - "evo-ai-redis-data${SUFFIX}:/data"
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  "evo-ai-redis-data${SUFFIX}":
    external: true
    name: "evo-ai-redis-data${SUFFIX}"

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOL

# Criar arquivo docker-compose para a stack PostgreSQL
echo -e "${VERDE}Criando arquivo docker-compose para a stack PostgreSQL...${RESET}"
cat > "${PG_STACK_NAME}.yaml" <<EOL
version: '3.8'
services:
  postgres${SUFFIX}:
    image: postgres:14-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: evo_ai${SUFFIX}
    ports:
      - "5432:5432"
    volumes:
      - "evo-ai-postgres-data${SUFFIX}:/var/lib/postgresql/data"
    networks:
      - GrowthNet
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  "evo-ai-postgres-data${SUFFIX}":
    external: true
    name: "evo-ai-postgres-data${SUFFIX}"

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOL

# Criar arquivo docker-compose para a stack Evo AI
echo -e "${VERDE}Criando arquivo docker-compose para a stack Evo AI...${RESET}"
# Gerar uma chave JWT aleatória se não houver uma fornecida
JWT_SECRET_KEY_DEFAULT=$(openssl rand -hex 32)
cat > "${EVO_AI_STACK_NAME}.yaml" <<EOL
version: "3.8"
services:
  api${SUFFIX}:
    image: evo-ai-api:latest
    depends_on:
      - postgres${SUFFIX}
      - redis${SUFFIX}
    ports:
      - "8000:8000"
    environment:
      POSTGRES_CONNECTION_STRING: postgresql://postgres:postgres@postgres${SUFFIX}:5432/evo_ai${SUFFIX}
      REDIS_HOST: redis${SUFFIX}
      REDIS_PORT: 6379
      REDIS_PASSWORD: ""
      REDIS_SSL: "false"
      REDIS_KEY_PREFIX: "a2a:"
      REDIS_TTL: 3600
      JWT_SECRET_KEY: "\${JWT_SECRET_KEY:-${JWT_SECRET_KEY_DEFAULT}}"
      SENDGRID_API_KEY: "\${SENDGRID_API_KEY}"
      EMAIL_FROM: "\${EMAIL_FROM}"
      APP_URL: "https://${EVO_AI_DOMAIN}"
      LOG_LEVEL: "\${LOG_LEVEL:-INFO}"
      DEBUG: "\${DEBUG:-false}"
    volumes:
      - "./evoai_logs${SUFFIX}:/app/logs"
      - "./evoai_static${SUFFIX}:/app/static"
    networks:
      - GrowthNet
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 15s
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.evoai${SUFFIX}.rule=Host(\`${EVO_AI_DOMAIN}\`)
        - traefik.http.routers.evoai${SUFFIX}.entrypoints=websecure
        - traefik.http.routers.evoai${SUFFIX}.priority=1
        - traefik.http.routers.evoai${SUFFIX}.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evoai${SUFFIX}.service=evoai${SUFFIX}
        - traefik.http.services.evoai${SUFFIX}.loadbalancer.server.port=8000
        - traefik.http.services.evoai${SUFFIX}.loadbalancer.passHostHeader=1

  postgres${SUFFIX}:
    image: postgres:14-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: evo_ai${SUFFIX}
    ports:
      - "5432:5432"
    volumes:
      - "evo-ai-postgres-data${SUFFIX}:/var/lib/postgresql/data"
    networks:
      - GrowthNet
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

  redis${SUFFIX}:
    image: redis:alpine
    command:
      - redis-server
      - --appendonly
      - "yes"
      - --requirepass
      - ""
    ports:
      - "6379:6379"
    volumes:
      - "evo-ai-redis-data${SUFFIX}:/data"
    networks:
      - GrowthNet
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 30s
      retries: 50
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
        - node.role == manager

volumes:
  "evo-ai-postgres-data${SUFFIX}":
    external: true
    name: "evo-ai-postgres-data${SUFFIX}"
  "evo-ai-redis-data${SUFFIX}":
    external: true
    name: "evo-ai-redis-data${SUFFIX}"

networks:
  GrowthNet:
    external: true
    name: GrowthNet
EOL

# Verificar se jq está instalado
if ! command -v jq &> /dev/null; then
    echo -e "${VERDE}Instalando jq...${RESET}"
    apt-get update && apt-get install -y jq || {
        error_exit "Falha ao instalar jq. Necessário para processamento de JSON."
    }
fi

# Obter token JWT do Portainer
echo -e "${VERDE}Autenticando no Portainer...${RESET}"
echo -e "URL do Portainer: ${BEGE}${PORTAINER_URL}${RESET}"

# Usar curl com a opção -k para ignorar verificação de certificado
AUTH_RESPONSE=$(curl -k -s -X POST "${PORTAINER_URL}/api/auth" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"${PORTAINER_USER}\",\"password\":\"${PORTAINER_PASSWORD}\"}" \
    -w "\n%{http_code}")

HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1)
AUTH_BODY=$(echo "$AUTH_RESPONSE" | sed '$d')

echo -e "Código HTTP retornado: ${BEGE}${HTTP_CODE}${RESET}"

if [ "$HTTP_CODE" -ne 200 ]; then
    echo "Erro na autenticação. Resposta completa:"
    echo "$AUTH_RESPONSE"

    # Tentar alternativa com HTTP em vez de HTTPS
    PORTAINER_URL_HTTP=$(echo "$PORTAINER_URL" | sed 's/https:/http:/')
    echo "Tentando alternativa com HTTP: ${PORTAINER_URL_HTTP}/api/auth"

    AUTH_RESPONSE=$(curl -s -X POST "${PORTAINER_URL_HTTP}/api/auth" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"${PORTAINER_USER}\",\"password\":\"${PORTAINER_PASSWORD}\"}" \
        -w "\n%{http_code}")

    HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1)
    AUTH_BODY=$(echo "$AUTH_RESPONSE" | sed '$d')

    echo "Código HTTP alternativo: ${HTTP_CODE}"

    if [ "$HTTP_CODE" -ne 200 ]; then
        error_exit "Autenticação falhou. Verifique a URL, usuário e senha do Portainer."
    else
        echo "Conexão bem-sucedida usando HTTP. Continuando com HTTP..."
        PORTAINER_URL="$PORTAINER_URL_HTTP"
    fi
fi

JWT_TOKEN=$(echo "$AUTH_BODY" | grep -o '"jwt":"[^"]*' | cut -d'"' -f4)

if [ -z "$JWT_TOKEN" ]; then
    error_exit "Não foi possível extrair o token JWT da resposta: $AUTH_BODY"
fi

echo -e "${VERDE}Autenticação bem-sucedida. Token JWT obtido.${RESET}"

# Listar endpoints disponíveis
echo -e "${VERDE}Listando endpoints disponíveis...${RESET}"
ENDPOINTS_RESPONSE=$(curl -k -s -X GET "${PORTAINER_URL}/api/endpoints" \
    -H "Authorization: Bearer ${JWT_TOKEN}" \
    -w "\n%{http_code}")

HTTP_CODE=$(echo "$ENDPOINTS_RESPONSE" | tail -n1)
ENDPOINTS_BODY=$(echo "$ENDPOINTS_RESPONSE" | sed '$d')

if [ "$HTTP_CODE" -ne 200 ]; then
    error_exit "Falha ao listar endpoints. Código HTTP: ${HTTP_CODE}, Resposta: ${ENDPOINTS_BODY}"
fi

echo -e "${VERDE}Endpoints disponíveis:${RESET}"
ENDPOINTS_LIST=$(echo "$ENDPOINTS_BODY" | grep -o '"Id":[0-9]*,"Name":"[^"]*' | sed 's/"Id":\([0-9]*\),"Name":"\([^"]*\)"/ID: \1, Nome: \2/')
echo "$ENDPOINTS_LIST"

# Selecionar automaticamente o primeiro endpoint disponível
ENDPOINT_ID=$(echo "$ENDPOINTS_BODY" | grep -o '"Id":[0-9]*' | head -1 | grep -o '[0-9]*')

if [ -z "$ENDPOINT_ID" ]; then
    error_exit "Não foi possível determinar o ID do endpoint."
else
    echo -e "Usando o primeiro endpoint disponível (ID: ${BEGE}${ENDPOINT_ID}${RESET})"
fi

# Verificar se o endpoint está em Swarm mode
echo -e "${VERDE}Verificando se o endpoint está em modo Swarm...${RESET}"
SWARM_RESPONSE=$(curl -k -s -X GET "${PORTAINER_URL}/api/endpoints/${ENDPOINT_ID}/docker/swarm" \
    -H "Authorization: Bearer ${JWT_TOKEN}" \
    -w "\n%{http_code}")

HTTP_CODE=$(echo "$SWARM_RESPONSE" | tail -n1)
SWARM_BODY=$(echo "$SWARM_RESPONSE" | sed '$d')

if [ "$HTTP_CODE" -ne 200 ]; then
    error_exit "Falha ao obter informações do Swarm. Código HTTP: ${HTTP_CODE}, Resposta: ${SWARM_BODY}"
fi

SWARM_ID=$(echo "$SWARM_BODY" | grep -o '"ID":"[^"]*' | cut -d'"' -f4)

if [ -z "$SWARM_ID" ]; then
    error_exit "Não foi possível extrair o ID do Swarm. O endpoint selecionado está em modo Swarm?"
fi

echo -e "ID do Swarm: ${BEGE}${SWARM_ID}${RESET}"

# Função para processar a criação ou atualização de uma stack
process_stack() {
    local stack_name=$1
    local yaml_file="${stack_name}.yaml"

    echo -e "${VERDE}Processando stack: ${BEGE}${stack_name}${RESET}"

    # Verificar se a stack já existe
    STACK_LIST_RESPONSE=$(curl -k -s -X GET "${PORTAINER_URL}/api/stacks" \
        -H "Authorization: Bearer ${JWT_TOKEN}" \
        -w "\n%{http_code}")

    HTTP_CODE=$(echo "$STACK_LIST_RESPONSE" | tail -n1)
    STACK_LIST_BODY=$(echo "$STACK_LIST_RESPONSE" | sed '$d')

    if [ "$HTTP_CODE" -ne 200 ]; then
